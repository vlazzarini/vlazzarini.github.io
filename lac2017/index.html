<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>C++ Instruments</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/moon.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
			  <section>
			  <H1>C++ Instruments:</h1>
			  <H2>The new Csound Opcode Plugin Framework</h2>
			  </section>
			  <section>
			  <section>
                          <H2>Introduction</h2>
			  </section>
			  <section>
			  <p>
                          Csound has a fairly straightforward plugin
		mechanism that can be used extend its language, adding
			  new native functionality to the system.
			  </p>
			  <p>
			  The main interface for this mechanism was
			  originally provided via the C language,
		which is also the language used in the core part of
		the software.
			  </p>
			  </section>
			  <section>
			  <p>
			  For many programmers, C++ is more accessible
			  language, even though it is much bigger and
		with a lot more conceptual complexities.
			  </p>
			  <p>
                          CPOF aims to provide an easy-to-use, heavily
			  re-usable, API for plugin opcode
			  development, with scalable qualities as far
			  complexity is concerned. 
			  </p>
			  </section>
			  <section>
			  <p> It is also important to point out that
		an alternative API by Michael Gogins provides some
			  of this functionality in Csound, trying to
			  add a C++ face to the underlying C-language
			  functions.
			  </p>
			  <p> However, CPOF has been designed from the
			  ground up with heavy use of templating to
			  provide a more complete C++ solution to the
			  problem. </p>
			  </section>
			  </section>
			  <section>
			  <section>
                          <H2> The C Opcode API </H1>
			  </section>
			  <section>
			  <p>
                          Adding an opcode to Csound in C involves
		three things </p>
			  <ol>
			   <li> A data structure containing the opcode
			    base, pointers to its out/in arguments (if
		any) and any state variables (if needed). 
			    </li>
			    <li> Up to three functions to compute the
		output at initialisation and/or performance times.
			    </li>
			     <li>
                             Boilerplate code to register the opcode
		with the system.
			    </li>
			    </ol>
			    </section>
			    <section>
                            <p> On startup, Csound finds all plugins,
			    and registers them with the system (using 3) <p>
			    <p> If an opcode is used in the code,
			    when this is instantiated, Csound
			    allocates memory for its data space (1), and calls its
			    processing functions (2) as appropriate.
                            </p>
			    </section>
			    <section>
                            <p> Generally, it is very simple to write
			    straightforward C opcodes. </p>
 			    <p> The complexity picks up quickly when
		we need resources from the system (memory allocation,
		function table access, advanced variable types, FFTs,
		etc.) to do more involved stuff.
                            </p>
			    </section>
<section data-markdown>
<textarea data-template>			    
``` c
#include <csdl.h>
/* 1 */
typedef struct opc {			    
 OPDS h;
 MYFLT *out, *xin, *kin, *iin;			    
 /* dataspace follows */
} OPC;
/* 2 */
int init(CSOUND *csound, OPC *p) {
 /* init-time code */
}
int kperf(CSOUND *csound, OPC *p) {
 /* control signal processing code */
}
int aperf(CSOUND *csound, OPC *p) {
 /* audio signal processing code */
}			    
/* 3 */
OENTRY localops[] = {
{"opc", sizeof(OPC), 5, 0, "a","aki",	    
(SUBR) init, NULL, (SUBR) aperf},
{"opc", sizeof(OPC), 3, 0, "k","kki",	    
(SUBR) init, (SUBR) kperf, NULL} };
LINKAGE
```

A skeleton of a C-language (polymorphic) plugin opcode.
</textarea>			    
</section>
</section>
<section>
                            <section>
                            <H2> CPOF API Basics </H2>
			    </section>
			    <section>
                            <p> The CPOF API is built on top of this tripartite
			    model. However, being C++, it employs
		significant code re-use through templates. So the
		three elements get reduced to two:
			    </p>
                            <ol>
			      <li> A class that defines the opcode. </li>
			      <li> A call to a registering (template)
			      function </li>
			    </ol>
			    </section>
			    <section>
			    <p>
                            The opcode class is derived from the
			    Plugin template base class:
			    </p>
			    <section data-markdown>
<textarea data-template>			    
``` c++
#include <plugin.h>
struct MyPlug : csnd::Plugin<1,1> { };
			    ```
</textarea>			    
</section>
<p>
The above is actually a minimum (but non-op) opcode with one output and one
input (the template parametes).
To do something, we will need to add
processsing methods to this class.
</p>
			    </section>
			    <section>
<p>			    
In Csound, an opcode can be active at init and/or perf times.
Init-time code is run once (e.g. on instantiation or re-initialisation
in the case of instruments). Perf-time code runs repeatedly when
Csound is processing audio or control signals. For each one of these
actions (init, control, or audio), an opcode can provide a computing			    
method: init(), kperf(), or aperf().
</p>

			   </section>
<section data-markdown>
<textarea data-template>			    
``` c++
struct Simplei : csnd::Plugin<1,1> {
  int init() {
    outargs[0] = inargs[0];
    return OK;
  }
};
			    ```

Because it implements only the init() method, this opcode can only run at init time.
</textarea>			    
			    </section>

<section data-markdown>
<textarea data-template>			    
``` c++
struct Simplek : csnd::Plugin<1,1> {
  int kperf() {
    outargs[0] = inargs[0];
    return OK;
  }
};
			    ```

			    
By implementing only the kperf() method, the
opcode can only run at performance time and process
control signals.
</textarea>			    
</section>

<section data-markdown>
<textarea data-template>			    
``` c++
struct Simplea : csnd::Plugin<1,1> {
  int aperf() {
    std::copy(inargs(0), inargs(0), outargs(0));
    return OK;
  }
};
			    ```

			  
By implementing only the aperf() method, the
opcode can only run at performance time and process
audio signals. Note that it handles
vectors of signals instead of single samples.
</textarea>			    
</section>
<section>
<p>
To register an opcode, we call a template function that takes the
class as its template parameter, plus the name, argument types and
action thread (init, perf, and/or audio). This template function
is called inside onload(), the entry point for the opcode plugin library. 
</p>
</section>

<section data-markdown>
<textarea data-template>			    
``` c++
#include <modload.h>
void csnd::on_load(Csound *csound) {
  csnd::plugin<Simplei>(csound, "simple", "i", "i", csnd::thread::i);
  csnd::plugin<Simplek>(csound, "simple", "k", "k", csnd::thread::k);
  csnd::plugin<Simplea>(csound, "simple", "a", "a", csnd::thread::a);
}
			    ```

The plugin() function parameters are self-explanatory: the Csound
engine, the opcode name, its argument types for output and input,  
and the opcode action times (i, k, a, ik, ia, ika).
</textarea>			    
</section>
</section>

<section>
<section>
<h2>Base Classes</h2>
</section>
<section data-markdown>
<textarea data-template>			    
The Opcode base class Plugin is derived from OPDS and
has a number of members that should be noted:

* outargs: output arguments (Params).
* inargs: input arguments (Params).
* csound: a pointer to the Csound engine object.
* offset: the starting position of an audio vector (for audio opcodes).
* nsmps: the size of an audio vector (also for audio opcodes only).

</textarea>			    
</section>
<section data-markdown>
<textarea data-template>			    
The other base class in the CPOF is FPlugin, derived from Plugin, which
provides an extra facility for fsig (streaming frequency-domain) plugins:

* framecount: a member to hold a running count of fsig frames.

</textarea>
</section>
<section data-markdown>
<textarea data-template>			    
Arguments are provided as two arrays of Params objects.
The Param class is iterable and has the following overloaded operators:

* operator[]: access each argument value as a MYFLT (floating-point type). For
use with scalar arguments
* operator() (also data()): function access gives the value as a MYFLT*, for use with vector arguments.
* fsig_data(), str_data(), vector_data(): for spectral, string, and
array type arguments.

</textarea>
</section>
<section data-markdown>
<textarea data-template>			    
While numeric scalar arguments can be dealt directly as floating-point
numbers, audio signals are vectors and should be treated as arrays. To
facilitate this, the AudioSig class can be used to wrap them conveniently:
``` c++
/** Constructor takes the plugin object and the
      audio argument pointer, and a reset flag if
      we need to clear an output buffer
   */
AudioSig::AudioSig(OPDS *p, MYFLT *s, bool res = false)
```
</textarea>
</section>
</section>

<section>
<h2> Support Classes </h2>
</section>

<section>
<section data-markdown>
<textarea data-template>			    
Memory allocation: AuxMem
---------------------------------------------------

For efficiency and to prevent leaks and undefined behaviour we need to
leave all memory allocation to Csound and refrain from using C++
allocators or standard library containers that use dynamic allocation
behind the scenes (e.g. std::vector). If we follow these rules, our code
will work as intended and cause no problems for users.

</textarea>
</section>

<section data-markdown>
<textarea data-template>			    
This requires us to use the AuxAlloc mechanism implemented by
Csound for opcodes. To allow for ease of use, CPOF provides a wrapper
template class (which is not too dissimilar to std::vector) for us to
allocate and use as much memory as we need.
</textarea>
</section>

<section data-markdown>
<textarea data-template>			    
This functionality
is given by the AuxMem class, which has the following methods and
members:

* allocate(): allocates memory (if required).
* operator[] : array-subscript access to the allocated memory.
* data(): returns a pointer to the data.
* len(): returns the length of the vector.
* begin() and end(): return iterators to the beginning and end of
data
* iterator and const_iterator: iterator types for this class.
</textarea>
</section>
<section data-markdown>
<textarea data-template>			    
```c++
struct DelayLine : csnd::Plugin<1, 2> {
 csnd::AuxMem<MYFLT> delay;
 csnd::AuxMem<MYFLT>::iterator iter;

 int init() {
  delay.allocate(csound, csound->sr() * inargs[1]);
  iter = delay.begin();
  return OK;
 }

 int aperf() {
  csnd::AudioSig in(this, inargs(0));
  csnd::AudioSig out(this, outargs(0));
  std::transform(in.begin(), in.end(), out.begin(),
   [this](MYFLT s) {
    MYFLT o = *iter;
    *iter = s;
    if (++iter == delay.end()) iter = delay.begin();
    return o;
   });
  return OK;
 }
};
```
</textarea>
</section>
</section>
<section>
<section data-markdown>
<textarea data-template>
Table Access: Table
-----------------------------------------------

Access to function tables has also been facilitated by a thin
wrapper class that allows us to treat it as a vector object.
This is provided by the Table class.
</textarea>
</section>

<section data-markdown>
<textarea data-template>
* init(): initialises a table object from an opcode argument pointer.
* operator[] : array-subscript access to the function table.
* data(): returns a pointer to the function table data.
* len(): returns the length of the table (excluding guard point).
* begin() and end(): return iterators to the beginning and end of
the function table
* iterator and const_iterator: iterator types for this class.
</textarea>
</section>
<section data-markdown>
<textarea data-template>			    
```c++
struct Oscillator : csnd::Plugin<1, 3> {
 csnd::Table tab;
 double scl;
 double x;

 int init() {
  tab.init(csound, inargs(2));
  scl = tab.len() / csound->sr();
  x = 0.;
  return OK;
 }

 int aperf() {
  csnd::AudioSig out(this, outargs(0));
  MYFLT amp = inargs[0];
  MYFLT si = inargs[1] * scl;
  for (auto &s : out) {
   s = amp * tab[(uint32_t)x];
   x += si;
   while (x < 0)
    x += tab.len();
   while (x >= tab.len())
    x -= tab.len();
   }
  return OK;
 }
};
```
</textarea>
</section>
</section>

<section>
<section data-markdown>
<textarea data-template>
Strings
---------------------------------------------

String variables in Csound are held in a STRINGDAT data structure,
containing a data member that holds the actual string and a size
member with the allocated memory size. While CPOF does not
wrap strings, it provides a translated access to string arguments
through the argument objects str_data() function. This takes a
an argument index (similarly to data()) and returns a reference to
the string variable.

</textarea>
</section>
<section data-markdown>
<textarea data-template>
```
/** i-time string plugin opcode example
    with only 1 input \n
    tprint Sin
 */
struct Tprint : csnd::Plugin<0,1> {
  int init() {
    csound->message(inargs.str_data(0).data);
    return OK;
  }
};
```
</textarea>
</section>
</section>

<section>
<section data-markdown>
<textarea data-template>
Fsigs
------------------------------------------------

For streaming spectral processing opcodes, we have a
different base class with extra facilities needed for their operation (FPlugin).
In Csound, fsig variables are held in a PVSDAT data structure. To
facilitate their manipulation, CPOF provides a wrapper class
csnd::Fsig for it. This holds a pv_frame, which itself contains a
series of pv_bins holding the floating-point data.
</textarea>
</section>

<section data-markdown>
<textarea data-template>

The Fsig class has the following methods:

* init(): initialisation from individual parameters or from an
existing fsig. Also allocates frame memory as needed.
* dft_size(), hop_size(), win_size(), win_type() and nbins(), returning the
PV data parameters.
* count(): get and set fsig framecount.
* isSliding(): checks for sliding mode.
* fsig_format(): returns the fsig data format.

</textarea>
</section>

<section data-markdown>
<textarea data-template>

The pv_frame class contains the following methods:

* operator[] : array-subscript access to the spectral frame
* data(): returns a pointer to the spectral frame data.
* len(): returns the length of the frame.
* begin() and end(): return iterators to the beginning and end of
the data frame.
* iterator and const_iterator: iterator types for this class.

</textarea>
</section>

<section data-markdown>
<textarea data-template>

Each Phase vocoder bin is held in a csnd::pv_bin container:

* amp(): returns the bin amplitude.
* freq(): returns the bin frequency.
* amp(float a): sets the bin amplitude to a.
* freq(float f): sets the bin frequency to f.
* operator*(pv_bin f): multiply the amp of a pvs bin by f.amp.
* operator*(MYFLT f): multiply the bin amp by f
* operator*=(): unary versions of the above.

</textarea>
</section>

<section data-markdown>
<textarea data-template>

```c++
/** f-sig plugin opcode example: pv gain change
    with 1 output and 2 inputs (f,k) \n
    fsig pvg fsin, kgain
 */
struct PVGain : csnd::FPlugin<1, 2> {
 static constexpr char const *otypes = "f";
 static constexpr char const *itypes = "fk";

 int init() {
  if (inargs.fsig_data(0).isSliding())
   return csound->init_error("sliding not supported");
    
  if (inargs.fsig_data(0).fsig_format()
   != csnd::fsig_format::pvs &&
    inargs.fsig_data(0).fsig_format()
   != csnd::fsig_format::polar)
    return csound->init_error("fsig format not supported");
		
  csnd::Fsig &fout = outargs.fsig_data(0);
  fout.init(csound, inargs.fsig_data(0));
  framecount = 0;
  return OK;
 }

 int kperf() {
  csnd::pv_frame &fin = inargs.fsig_data(0);
  csnd::pv_frame &fout = outargs.fsig_data(0);
  uint32_t i;

  if (framecount < fin.count()) {
   MYFLT g = inargs[1];
   std::transform(fin.begin(), fin.end(), fout.begin(),
    [g](csnd::pv_bin f){ return f *= g; });
   framecount = fout.count(fin.count());
  }
  return OK;
 }
};
```
</textarea>
</section>
</section>

<section>
<section data-markdown>
<textarea data-template>
Arrays: Vector
----------------------------------------------

Opcodes with array inputs or outputs use the data structure ARRAYDAT
for parameters. Again, in order to facilitate access to these argument
types, CPOF provides a wrapper class, Vector. This currently supports
only one-dimensional arrays (for multidimensional arrays a raw pointer
to ARRAYDAT should be used), which nevertheless covers the most common uses.
</textarea>
</section>
<section data-markdown>
<textarea data-template>
* init(): initialises an output variable.
* operator[] : array-subscript access to the vector data.
* data(): returns a pointer to the vector data.
* len(): returns the length of the vector.
* begin() and end(): return iterators to the beginning and end of
the vector.
* iterator and const_iterator: iterator types for this class.
* data_array(): returns a pointer to the vector data.
</textarea>
</section>

<section data-markdown>
<textarea data-template>
```c++
/** k-rate numeric array example
    with 1 output and 1 input \n
    kout[] simple kin[]
 */
struct SimpleArray : csnd::Plugin<1, 1> {
  int init() {
    csnd::Vector<MYFLT> &out = outargs.vector_data<MYFLT>(0);
    csnd::Vector<MYFLT> &in = inargs.vector_data<MYFLT>(0);
    out.init(csound, in.len());
    return OK;
  }

  int kperf() {
    csnd::Vector<MYFLT> &out = outargs.vector_data<MYFLT>(0);
    csnd::Vector<MYFLT> &in = inargs.vector_data<MYFLT>(0);
    std::copy(in.begin(), in.end(), out.begin());
    return OK;
  }
  };
```
</textarea>
</section>
</section>
<section data-markdown>
<textarea data-template>
Building the opcodes
-------------------------------------------

In order to plugin opcodes with CPOF, we require a c++
compiler using c++11 mode (-std=c++11), and the Csound public
headers (including plugin.h). The code should be built as a dynamic/shared
library (e.g so in Linux and dylib in OSX). CPOF does not impose any
link-time dependencies (not even to Csound).

[http://csound.github.io](http://csound.github.io)

</textarea>
</section>

</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
