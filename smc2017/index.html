<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>The Csound Opcode Pugin Framework</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/moon.css">

		<!-- Theme used for syntax highlighting of code -->
<link rel="stylesheet" href="lib/css/zenburn.css">

<style type="text/css">
p { text-align: left; }
</style>

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
               </script>

<script type="text/javascript" src="js/csound.js"></script>
 <script type="text/javascript">
 // called by csound.js
 function moduleDidLoad() {
   csound.CopyUrlToLocal("eskers1.wav","eskers1.wav", function() {
     fcopied = true;
     console.log("Engine ready. \nPowered by Web Assembly Csound\n");
});
  loaded = true;
 }
 function attachListeners() { 
  document.getElementById('playButton').
   addEventListener('click', togglePlay);
  document.getElementById("trace").
       addEventListener("input",SetTrace);
 }

 function SetTrace() {
  var val = document.getElementById('trace').value
  csound.setControlChannel('trace', val);
 }


 var fcopied = false;
 var count = 0;

 function handleMessage(message) {
   var element = document.getElementById('console');
   element.value += message;
   count += 1;
   if(count == 1000) {
     element.value = ' ';
     count = 0;
   }
 }

 var playing = false;
 var started = false;
 var loaded = false;

 function togglePlay(){
  if(loaded && fcopied) {
  if(!playing) {
  if(started) csound.Play();
  else {
   csound.PlayCsd("pvstrace.csd");
   started = true;
  }
  document.getElementById('playButton').innerText = "Pause";
  playing = true;
  } else {
  csound.Csound.stop()
  document.getElementById('playButton').innerText ="Play";
  playing = false;
  }
}
}
 
</script>

<style>
.playbutton {
    background-color: #4CAF50;
    border: none;
    color: white;
    padding: 15px 32px;
    text-align: center;
    text-decoration: none;
    display: inline-block;
    font-size: 16px;
    margin: 4px 2px;
    cursor: pointer;
}

input[type=range] {
  height: 8px;
  -webkit-appearance: none;
  /*margin: 10px 0;*/
  width: 70%;
}
input[type=range]:focus {
  outline: none;
}
input[type=range]::-webkit-slider-runnable-track {
  width: 100%;
  height: 8px;
  cursor: pointer;
  animate: 0.2s;
  background: #205928;
  border-radius: 1px;
  /*border: 1px solid #18D501;*/
}
input[type=range]::-webkit-slider-thumb {
  /*box-shadow: 3px 3px 3px #00AA00;*/
  border: 2px solid #83E584;
  height: 23px;
  width: 23px;
  border-radius: 23px;
  background: #439643;
  cursor: pointer;
  -webkit-appearance: none;
  margin-top: -7px;
}
input[type=range]:focus::-webkit-slider-runnable-track {
  background: #205928;
}


</style>


	</head>
	<body>
		<div class="reveal">
			<div class="slides">
			  <section>
			  <H1>CPOF:</h1>
			  <H2>The new Csound Opcode Plugin Framework</h2>
			  </section>
			  <section>
			  <section>
                          <H2>Introduction</h2>
			  </section>
			  <section>
			  <h2>Plugins</h2>
			  <p>
                          Csound has a fairly straightforward <b>plugin</b>
		mechanism that can be used extend its language, adding
			  new native functionality to the system in
			  the form of new <i>opcodes</i> (or unit generators).
			  
			  </p>
			  <p>
			  The main interface for this mechanism was
			  originally provided via the C language,
		which is also the language used in the core part of
		the software.
			  </p>
			  </section>
			  <section>
			  <h2> C++ Opcodes </h2>
			  <p>
			  For many programmers, C++ is a more accessible
			  language, even though it is much bigger and
		with a lot more conceptual complexities.
			  </p>
			  <p>
                          CPOF aims to provide an easy-to-use, scalable, heavily
			  re-usable, object-oriented <i>framework</i> for plugin opcode
			  development.
			  </p>
			  </section>
			  </section>
                          <section>
                            <section>
                            <H2> CPOF Basics </H2>
			    </section>
			    <section>
                            <p> An Opcode is created using CPOF by
			  providing the following C++ code:
			    </p>
                            <ol>
			      <li> A class that defines the opcode. </li>
			      <li> A call to a registering (template)
			      function </li>
			    </ol>
			    </section>

<section data-markdown>
<textarea data-template>
Base Classes
---------------			    
The base class for most opcodes is `Plugin`. Derived from it, we have
`FPlugin`, derived from `Plugin`, which is designed for
frequency-domain plugins.

</textarea>
</section>

			    <section data-markdown>

			    <textarea data-template>
			    Defining Opcodes
			    --------
			     An opcode class is derived from this
			    template base class:
``` c++
#include <plugin.h>
			    struct MyPlug : csnd::Plugin<1,1> { };
			    ```
			  This is actually a complete (but non-op) opcode with one output and one
input (given by the template parameters). To this, we need to add processsing methods.
</textarea>			    

			    </section>
<section data-markdown>
			    <textarea data-template>
Action Times
--------------
In Csound, an opcode can be active at init and/or perf times:
1. Init-time code is run once.
2. Perf-time code runs repeatedly to process signals.

For each one of these actions (init; control or audio processing) an
			    opcode class can provide a computing method:
			    `init()`, `kperf()`, or `aperf()`.
</textarea>
</section>
<section data-markdown>
<textarea data-template>
Init-time
------------
``` c++
struct Simplei : csnd::Plugin<1,1> {
  int init() {
     outargs[0] = inargs[0];
     return OK;
  }
};
```
Arguments to opcodes are provided as two arrays of `Params` objects,
`outargs` and `inargs`, for output and input, respectively. From these we can get the
various types of Csound data: scalars (as in the example above),
			    vectors, strings, arrays,
			    or fsigs.
</textarea>			    
			    </section>

<section data-markdown>
<textarea data-template>
Perf-time (Control Signals)
-------------------------
``` c++
struct Simplek : csnd::Plugin<1,1> {
  int kperf() {
     outargs[0] = inargs[0];
     return OK;
  }
};
```

			    
By implementing only the `kperf()` method, the
opcode can only run at performance time and process
control signals.
</textarea>			    
</section>

<section data-markdown>
<textarea data-template>
Perf-time (Audio Signals)
--------------------
``` c++
struct Simplea : csnd::Plugin<1,1> {
  int aperf() {
    std::copy(inargs(0)+offset, inargs(0)+nsmps, outargs(0));
    return OK;
  }
};
```

			  
By implementing only the `aperf()` method, the
opcode can only run at performance time and process
audio signals. Note that it handles
vectors of signals instead of single samples, and that it
processes `nsmps` of input data starting at `offset`.
</textarea>			    
</section>
<section data-markdown>
<textarea data-template>
Adding Opcodes
-------------
To register an opcode with Csound, we call a template function that takes the
class as its template parameter, plus the name, argument types and
action thread (init, perf, and/or audio). This template function
is called inside `onload()`, the entry point for the opcode plugin library. 
</textarea>
</section>

<section data-markdown>
<textarea data-template>
ON LOAD
------------
``` c++
#include <modload.h>
void csnd::on_load(Csound *csound) {
 csnd::plugin<Simplei>(csound, "simple", "i", "i",
                                  csnd::thread::i);
 csnd::plugin<Simplek>(csound, "simple", "k", "k",
                                  csnd::thread::k);
 csnd::plugin<Simplea>(csound, "simple", "a", "a",
                                  csnd::thread::a);
}
```

`plugin()` takes the opcode class name as a template
parameter. Its arguments are: the Csound
engine, the opcode name, its argument types for output and input,  
and the opcode action times (`i`, `k`, `a`, `ik`, `ia`, `ika`).
</textarea>			    
</section>
</section>

<section>
<h2> Support Classes </h2>
</section>


<section>
<section data-markdown>
<textarea data-template>
Audio Signals
------------------------
While scalars can be dealt directly as floating-point
numbers, audio signals are vectors and need some special care.
The `AudioSig` class can be used to wrap them conveniently:
``` c++
/** Constructor takes the plugin object and the
      audio argument pointer, and a reset flag if
      we need to clear an output buffer
   */
AudioSig::AudioSig(OPDS *p, MYFLT *s, bool res = false);
```
</textarea>
</section>
</section>
<section>
<section data-markdown>
<textarea data-template>			    
Memory allocation
---------------------------------------------------

For efficiency and to prevent leaks and undefined behaviour we need to
leave memory management to Csound and **AVOID ALL** C++
allocators or containers that use them (e.g. `std::vector`).

CPOF provides the `AuxMem` class for opcodes that need dynamic
memory allocation. This delegates memory management to Csound.
</textarea>
</section>

<section data-markdown>
<textarea data-template>			    
```c++
struct DelayLine : csnd::Plugin<1, 2> {
 csnd::AuxMem<MYFLT> delay;
 csnd::AuxMem<MYFLT>::iterator iter;

 int init() {
  delay.allocate(csound, csound->sr() * inargs[1]);
  iter = delay.begin();
  return OK;
 }

 int aperf() {
  csnd::AudioSig in(this, inargs(0));
  csnd::AudioSig out(this, outargs(0));
  std::transform(in.begin(), in.end(), out.begin(),
   [this](MYFLT s) {
    MYFLT o = *iter;
    *iter = s;
    if (++iter == delay.end()) iter = delay.begin();
    return o;
   });
  return OK;
 }
};
```
</textarea>
</section>
</section>
<section>
<section data-markdown>
<textarea data-template>
Table Access
-----------------------------------------------
Csound uses function tables in all sorts of applications, from
oscillators to sequencers to convolution reverb and beyond.

Access to these has  been facilitated by a thin
wrapper that allows us to treat it as a vector object.
This is provided by the `Table` class.
</textarea>
</section>
<section data-markdown>
<textarea data-template>			    
```c++
struct Oscillator : csnd::Plugin<1, 3> {
 csnd::Table tab;
 double scl;
 double x;

 int init() {
  tab.init(csound, inargs(2));
  scl = tab.len() / csound->sr();
  x = 0.;
  return OK;
 }

 int aperf() {
  csnd::AudioSig out(this, outargs(0));
  MYFLT amp = inargs[0];
  MYFLT si = inargs[1] * scl;
  for (auto &s : out) {
   s = amp * tab[(uint32_t)x];
   x += si;
   while (x < 0) x += tab.len();
   while (x >= tab.len()) x -= tab.len();
   }
  return OK;
 }
};
```
</textarea>
</section>
</section>

<section>
<section data-markdown>
<textarea data-template>
Strings
---------------------------------------------

String variables are held in a `STRINGDAT` data structure.
While CPOF does not wrap strings, it provides access to string-type arguments
through the `str_data()` method (from `Params`). It takes a
an argument index and returns a reference to a `STRINGDAT`.

</textarea>
</section>
<section data-markdown>
<textarea data-template>
```
/** i-time string plugin opcode example
    with only 1 input \n
    tprint Sin
 */
struct Tprint : csnd::Plugin<0,1> {
  int init() {
    csound->message(inargs.str_data(0).data);
    return OK;
  }
};
```
</textarea>
</section>
</section>

<section>
<section data-markdown>
<textarea data-template>
Fsigs
------------------------------------------------

Fsig (frequency-domain) variables are held in a `PVSDAT` structure. To
facilitate their manipulation, `CPOF` provides a wrapper class
`Fsig` for it. This holds a `pv_frame`, which itself contains a
series of `pv_bins` holding the floating-point data.
</textarea>
</section>
<section data-markdown>
<textarea data-template>

```c++
struct PVTrace : csnd::FPlugin<1, 2> {
  csnd::AuxMem<float> amps;

  int init() {
    amps.allocate(csound, inargs.fsig_data(0).nbins());
    csnd::Fsig &fout = outargs.fsig_data(0);
    fout.init(csound, inargs.fsig_data(0));
    framecount = 0;
    return OK;
  }

  int kperf() {
    csnd::pv_frame &fin = inargs.fsig_data(0);
    csnd::pv_frame &fout = outargs.fsig_data(0);

    if (framecount < fin.count()) {
      int n = fin.len() - (int)inargs[1];
      float thrsh;
      std::transform(fin.begin(), fin.end(), amps.begin(),
                     [](csnd::pv_bin f) { return f.amp(); });
      std::nth_element(amps.begin(), amps.begin() + n,
                     amps.end());
      thrsh = amps[n];
      std::transform(fin.begin(), fin.end(), fout.begin(),
                     [thrsh](csnd::pv_bin f) {
                            return f.amp() >= thrsh ?
                                   f : csnd::pv_bin(); });
      framecount = fout.count(fin.count());
    }

    return OK;
  }

};
```
</textarea>
</section>
<section>
<textarea class="console" cols="100" rows="30" id="console"
  value="">Csound: not loaded</textarea>
<p>
<div id="center">
  <button class="playbutton" id="playButton" width="40">play</button> <br>
  spectral trace<br>
  <input type="range" name="trace" id="trace" step="1" value="50"
  min="1" max="128">
</div>
 

</section>

</section>

<section>
<section data-markdown>
<textarea data-template>
Arrays
----------------------------------------------

Array variables are defined by the `ARRAYDAT` structure. 
CPOF provides a wrapper class, `Vector`. This currently supports
only one-dimensional arrays, which covers the most common applications.
</textarea>
</section>
<section data-markdown>
<textarea data-template>
```c++
/** k-rate numeric array example
    with 1 output and 1 input \n
    kout[] simple kin[]
 */
struct SimpleArray : csnd::Plugin<1, 1> {
  int init() {
    csnd::Vector<MYFLT> &out = outargs.vector_data<MYFLT>(0);
    csnd::Vector<MYFLT> &in = inargs.vector_data<MYFLT>(0);
    out.init(csound, in.len());
    return OK;
  }

  int kperf() {
    csnd::Vector<MYFLT> &out = outargs.vector_data<MYFLT>(0);
    csnd::Vector<MYFLT> &in = inargs.vector_data<MYFLT>(0);
    std::copy(in.begin(), in.end(), out.begin());
    return OK;
  }
  };
```
</textarea>
</section>
</section>
<section>
<section data-markdown>
<textarea data-template>
Extreme Code Re-use 
-------------------------------------------
The following example implements 44 distinct opcodes from a single
class template, demonstrating an extreme case of
code re-use.
</textarea>
</section>
<section data-markdown>
<textarea data-template>
```
/** i-time, k-rate array operator
    i/kout[] op i/kin[]
 */
template <MYFLT (*op)(MYFLT)>
struct ArrayOp : csnd::Plugin<1, 1> {

  int process(csnd::myfltvec &out, csnd::myfltvec &in) {
    std::transform(in.begin(), in.end(), out.begin(),
                   [](MYFLT f) { return op(f); });
    return OK;
  }

  int init() {
    csnd::myfltvec &out = outargs.myfltvec_data(0);
    csnd::myfltvec &in = inargs.myfltvec_data(0);
    out.init(csound, in.len());
    return process(out, in);
  }

  int kperf() {
   return process(outargs.myfltvec_data(0),
               inargs.myfltvec_data(0));
  }
};

#include <modload.h>
void csnd::on_load(Csound *csound) {
 csnd::plugin<ArrayOp<std::ceil>>(csound, "ceil", "i[]", "i[]",
                                   csnd::thread::i);
 csnd::plugin<ArrayOp<std::ceil>>(csound, "ceil", "k[]", "k[]",
                                   csnd::thread::ik);
 csnd::plugin<ArrayOp<std::floor>>(csound, "floor", "i[]", "i[]",
                                    csnd::thread::i);
 csnd::plugin<ArrayOp<std::floor>>(csound, "floor", "k[]", "k[]",
                                    csnd::thread::ik);
 csnd::plugin<ArrayOp<std::round>>(csound, "round", "i[]", "i[]",
                                    csnd::thread::i);
 csnd::plugin<ArrayOp<std::round>>(csound, "round", "k[]", "k[]",
                                    csnd::thread::ik);
 csnd::plugin<ArrayOp<std::trunc>>(csound, "int", "i[]", "i[]",
                                    csnd::thread::i);
 csnd::plugin<ArrayOp<std::trunc>>(csound, "int", "k[]", "k[]",
                                    csnd::thread::i);
 csnd::plugin<ArrayOp<std::exp2>>(csound, "powoftwo", "i[]", "i[]",
                                   csnd::thread::i);
 csnd::plugin<ArrayOp<std::exp2>>(csound, "powoftwo", "k[]", "k[]",
                                   csnd::thread::ik);
 csnd::plugin<ArrayOp<std::fabs>>(csound, "abs", "i[]", "i[]",
                                   csnd::thread::i);
 csnd::plugin<ArrayOp<std::fabs>>(csound, "abs", "k[]", "k[]",
                                   csnd::thread::ik);
 csnd::plugin<ArrayOp<std::log10>>(csound, "log2", "i[]", "i[]",
                                    csnd::thread::i);
 csnd::plugin<ArrayOp<std::log10>>(csound, "log2", "k[]", "k[]",
                                    csnd::thread::ik);
 csnd::plugin<ArrayOp<std::log10>>(csound, "log10", "i[]", "i[]",
                                    csnd::thread::i);
 csnd::plugin<ArrayOp<std::log10>>(csound, "log10", "k[]", "k[]",
                                    csnd::thread::ik);
 csnd::plugin<ArrayOp<std::log>>(csound, "log", "i[]", "i[]",
                                    csnd::thread::i);
 csnd::plugin<ArrayOp<std::log>>(csound, "log", "k[]", "k[]",
                                    csnd::thread::ik);
 csnd::plugin<ArrayOp<std::exp>>(csound, "exp", "i[]", "i[]",
                                      csnd::thread::i);
 csnd::plugin<ArrayOp<std::exp>>(csound, "exp", "k[]", "k[]",
                                     csnd::thread::ik);
 csnd::plugin<ArrayOp<std::sqrt>>(csound, "sqrt", "i[]", "i[]",
                                   csnd::thread::i);
 csnd::plugin<ArrayOp<std::sqrt>>(csound, "sqrt", "k[]", "k[]",
                                   csnd::thread::ik);
 csnd::plugin<ArrayOp<std::cos>>(csound, "cos", "i[]", "i[]",
                                    csnd::thread::i);
 csnd::plugin<ArrayOp<std::cos>>(csound, "cos", "k[]", "k[]",
                                  csnd::thread::ik);
 csnd::plugin<ArrayOp<std::sin>>(csound, "sin", "i[]", "i[]",
                                  csnd::thread::i);
 csnd::plugin<ArrayOp<std::sin>>(csound, "sin", "k[]", "k[]",
                                  csnd::thread::ik);
 csnd::plugin<ArrayOp<std::tan>>(csound, "tan", "i[]", "i[]",
                                    csnd::thread::i);
 csnd::plugin<ArrayOp<std::tan>>(csound, "tan", "k[]", "k[]",
                                  csnd::thread::ik);
 csnd::plugin<ArrayOp<std::acos>>(csound, "cosinv", "i[]", "i[]",
                                   csnd::thread::i);
 csnd::plugin<ArrayOp<std::acos>>(csound, "cosinv", "k[]", "k[]",
                                   csnd::thread::ik);
 csnd::plugin<ArrayOp<std::asin>>(csound, "sininv", "i[]", "i[]",
                                   csnd::thread::i);
 csnd::plugin<ArrayOp<std::asin>>(csound, "sininv", "k[]", "k[]",
                                   csnd::thread::ik);
 csnd::plugin<ArrayOp<std::atan>>(csound, "taninv", "i[]", "i[]",
                                   csnd::thread::i);
 csnd::plugin<ArrayOp<std::atan>>(csound, "taninv", "k[]", "k[]",
                                   csnd::thread::ik);
 csnd::plugin<ArrayOp<std::cosh>>(csound, "cosh", "i[]", "i[]",
                                   csnd::thread::i);
 csnd::plugin<ArrayOp<std::cosh>>(csound, "cosh", "k[]", "k[]",
                                   csnd::thread::ik);
 csnd::plugin<ArrayOp<std::sinh>>(csound, "sinh", "i[]", "i[]",
                                   csnd::thread::i);
 csnd::plugin<ArrayOp<std::sinh>>(csound, "sinh", "k[]", "k[]",
                                   csnd::thread::ik);
 csnd::plugin<ArrayOp<std::tanh>>(csound, "tanh", "i[]", "i[]",
                                   csnd::thread::i);
 csnd::plugin<ArrayOp<std::tanh>>(csound, "tanh", "k[]", "k[]",
                                   csnd::thread::ik);
 csnd::plugin<ArrayOp<std::cbrt>>(csound, "cbrt", "i[]", "i[]",
                                   csnd::thread::i);
}
```
</textarea>
</section>
</section>
<section data-markdown>
<textarea data-template>
Building & Finding Out More
-------------------------------------------

In order to plugin opcodes with CPOF, we require a c++
compiler using c++11 mode (`-std=c++11`), and the Csound public
headers (including `plugin.h`).

The code should be built as a dynamic/shared
library. CPOF does not impose any special link-time dependencies
(not even to Csound).

<div class=align-center>
[http://csound.github.io](http://csound.github.io)
</div>
</textarea>
</section>

</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
		Reveal.initialize({
		   
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				],       
			});
		</script>
	</body>
</html>
