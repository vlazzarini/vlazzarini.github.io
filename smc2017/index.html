<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>CPOF</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/league.css">

		<!-- Theme used for syntax highlighting of code -->
<link rel="stylesheet" href="lib/css/zenburn.css">

<style type="text/css">
p { text-align: left; }
</style>

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
			  <section>
			  <H1>CPOF:</h1>
			  <H2>The new Csound Opcode Plugin Framework</h2>
			  </section>
			  <section>
			  <section>
                          <H2>Introduction</h2>
			  </section>
			  <section>
			  <p>
                          Csound has a fairly straightforward plugin
		mechanism that can be used extend its language, adding
			  new native functionality to the system.
			  </p>
			  <p>
			  The main interface for this mechanism was
			  originally provided via the C language,
		which is also the language used in the core part of
		the software.
			  </p>
			  </section>
			  <section>
			  <p>
			  For many programmers, C++ is a more accessible
			  language, even though it is much bigger and
		with a lot more conceptual complexities.
			  </p>
			  <p>
                          CPOF aims to provide an easy-to-use, heavily
			  re-usable, API for plugin opcode
			  development, with scalable qualities as far
			  complexity is concerned. 
			  </p>
			  </section>
			  <section>
			  <p> It is also important to point out that
		an alternative API by Michael Gogins provides some
			  of this functionality in Csound, trying to
			  add a C++ face to the underlying C-language
			  functions.
			  </p>
			  <p> However, CPOF has been designed from the
			  ground up with heavy use of templating to
			  provide a more complete C++ solution to the
			  problem. </p>
			  </section>
			  </section>
                          <section>
                            <section>
                            <H2> CPOF Basics </H2>
			    </section>
			    <section>
                            <p> An Opcode is created using CPOF by
			  providing the following C++ code:
			    </p>
                            <ol>
			      <li> A class that defines the opcode. </li>
			      <li> A call to a registering (template)
			      function </li>
			    </ol>
			    </section>
			    <section>
			    <p>
                            The opcode class is derived from the
			    Plugin template base class:
			    </p>
			    <section data-markdown>
<textarea data-template>			    
``` c++
#include <plugin.h>
struct MyPlug : csnd::Plugin<1,1> { };
			    ```
</textarea>			    
</section>
<p>
The above is actually a minimum (but non-op) opcode with one output and one
input (the template parametes).
To do something, we will need to add
processsing methods to this class.
</p>
			    </section>
<section data-markdown>
<textarea data-template>			    
In Csound, an opcode can be active at init and/or perf times.
Init-time code is run once (e.g. on instantiation or re-initialisation
in the case of instruments). Perf-time code runs repeatedly when
Csound is processing audio or control signals. For each one of these
actions (init, control, or audio), an opcode can provide a computing method:
			    `init()`, `kperf()`, or `aperf()`.
</textarea>

			   </section>
<section data-markdown>
<textarea data-template>			    
``` c++
struct Simplei : csnd::Plugin<1,1> {
  int init() {
    outargs[0] = inargs[0];
    return OK;
  }
};
			    ```

Because it implements only the `init()` method, this opcode can only run at init time.
</textarea>			    
			    </section>

<section data-markdown>
<textarea data-template>			    
``` c++
struct Simplek : csnd::Plugin<1,1> {
  int kperf() {
    outargs[0] = inargs[0];
    return OK;
  }
};
			    ```

			    
By implementing only the `kperf()` method, the
opcode can only run at performance time and process
control signals.
</textarea>			    
</section>

<section data-markdown>
<textarea data-template>			    
``` c++
struct Simplea : csnd::Plugin<1,1> {
  int aperf() {
    std::copy(inargs(0)+offset, inargs(0)+nsmps, outargs(0));
    return OK;
  }
};
			    ```

			  
By implementing only the `aperf()` method, the
opcode can only run at performance time and process
audio signals. Note that it handles
vectors of signals instead of single samples, and that it
processes `nsmps` of input data starting at `offset`.
</textarea>			    
</section>
<section data-markdown>
<textarea data-template>
To register an opcode, we call a template function that takes the
class as its template parameter, plus the name, argument types and
action thread (init, perf, and/or audio). This template function
is called inside `onload()`, the entry point for the opcode plugin library. 
</textarea>
</section>

<section data-markdown>
<textarea data-template>			    
``` c++
#include <modload.h>
void csnd::on_load(Csound *csound) {
  csnd::plugin<Simplei>(csound, "simple", "i", "i", csnd::thread::i);
  csnd::plugin<Simplek>(csound, "simple", "k", "k", csnd::thread::k);
  csnd::plugin<Simplea>(csound, "simple", "a", "a", csnd::thread::a);
}
			    ```

The `plugin()` function takes the opcode class name as a template
parameter. Its arguments are self-explanatory: the Csound
engine, the opcode name, its argument types for output and input,  
and the opcode action times (`i`, `k`, `a`, `ik`, `ia`, `ika`).
</textarea>			    
</section>
</section>

<section>
<section>
<h2>Base Classes</h2>
</section>
<section data-markdown>
<textarea data-template>			    
The Opcode base class `Plugin` is derived from `OPDS` and
has a number of members that should be noted:

* `outargs`: output arguments (`Params` object).
* `inargs`: input arguments (`Params` object).
* `csound`: a pointer to the `Csound` engine object.
* `offset`: the starting position of an audio vector (for audio opcodes).
* `nsmps`: the size of an audio vector (also for audio opcodes only).

</textarea>			    
</section>
<section data-markdown>
<textarea data-template>			    
The other base class in the CPOF is `FPlugin`, derived from `Plugin`, which
provides an extra facility for fsig (streaming frequency-domain) plugins:

* `framecount`: a member to hold a running count of fsig frames.

</textarea>
</section>
<section data-markdown>
<textarea data-template>			    
Arguments are provided as two arrays of `Params` objects.
The `Param` class is iterable and has the following overloaded operators:

* `operator[]`: access each argument value as a `MYFLT` (floating-point type). For
use with scalar arguments
* `operator()` (also `data()`): function access gives the value as a `MYFLT*`, for use with vector arguments.
* `fsig_data()`, `str_data()`, `vector_data()`: for spectral, string, and
array type arguments.

</textarea>
</section>
<section data-markdown>
<textarea data-template>			    
While numeric scalar arguments can be dealt directly as floating-point
numbers, audio signals are vectors and should be treated as arrays. To
facilitate this, the `AudioSig` class can be used to wrap them conveniently:
``` c++
/** Constructor takes the plugin object and the
      audio argument pointer, and a reset flag if
      we need to clear an output buffer
   */
AudioSig::AudioSig(OPDS *p, MYFLT *s, bool res = false)
```
</textarea>
</section>
</section>

<section>
<h2> Support Classes </h2>
</section>

<section>
<section data-markdown>
<textarea data-template>			    
Memory allocation
---------------------------------------------------

For efficiency and to prevent leaks and undefined behaviour we need to
leave all memory allocation to Csound and refrain from using C++
allocators or standard library containers that use dynamic allocation
behind the scenes (e.g. `std::vector`). If we follow these rules, our code
will work as intended and cause no problems for users.

</textarea>
</section>

<section data-markdown>
<textarea data-template>			    
This requires us to use the `AuxAlloc` mechanism implemented by
Csound for opcodes. To allow for ease of use, CPOF provides a wrapper
template class (which is not too dissimilar to `std::vector`) for us to
allocate and use as much memory as we need.
</textarea>
</section>

<section data-markdown>
<textarea data-template>			    
This functionality
is given by the `AuxMem` class, which has the following methods and
members:

* `allocate()`: allocates memory (if required).
* `operator[]`: array-subscript access to the allocated memory.
* `data()`: returns a pointer to the data.
* `len()`: returns the length of the vector.
* `begin()` and `end()`: return iterators to the beginning and end of
data
* `iterator` and `const_iterator`: iterator types for this class.
</textarea>
</section>
<section data-markdown>
<textarea data-template>			    
```c++
struct DelayLine : csnd::Plugin<1, 2> {
 csnd::AuxMem<MYFLT> delay;
 csnd::AuxMem<MYFLT>::iterator iter;

 int init() {
  delay.allocate(csound, csound->sr() * inargs[1]);
  iter = delay.begin();
  return OK;
 }

 int aperf() {
  csnd::AudioSig in(this, inargs(0));
  csnd::AudioSig out(this, outargs(0));
  std::transform(in.begin(), in.end(), out.begin(),
   [this](MYFLT s) {
    MYFLT o = *iter;
    *iter = s;
    if (++iter == delay.end()) iter = delay.begin();
    return o;
   });
  return OK;
 }
};
```
</textarea>
</section>
</section>
<section>
<section data-markdown>
<textarea data-template>
Table Access
-----------------------------------------------

Access to function tables has also been facilitated by a thin
wrapper class that allows us to treat it as a vector object.
This is provided by the `Table` class.
</textarea>
</section>

<section data-markdown>
<textarea data-template>
* `init()`: initialises a table object from an opcode argument pointer.
* `operator[]`: array-subscript access to the function table.
* `data()`: returns a pointer to the function table data.
* `len()`: returns the length of the table (excluding guard point).
* `begin()` and `end()`: return iterators to the beginning and end of
the function table
* `iterator` and `const_iterator`: iterator types for this class.
</textarea>
</section>
<section data-markdown>
<textarea data-template>			    
```c++
struct Oscillator : csnd::Plugin<1, 3> {
 csnd::Table tab;
 double scl;
 double x;

 int init() {
  tab.init(csound, inargs(2));
  scl = tab.len() / csound->sr();
  x = 0.;
  return OK;
 }

 int aperf() {
  csnd::AudioSig out(this, outargs(0));
  MYFLT amp = inargs[0];
  MYFLT si = inargs[1] * scl;
  for (auto &s : out) {
   s = amp * tab[(uint32_t)x];
   x += si;
   while (x < 0)
    x += tab.len();
   while (x >= tab.len())
    x -= tab.len();
   }
  return OK;
 }
};
```
</textarea>
</section>
</section>

<section>
<section data-markdown>
<textarea data-template>
Strings
---------------------------------------------

String variables in Csound are held in a `STRINGDAT` data structure,
containing a data member that holds the actual string and a size
member with the allocated memory size. While CPOF does not
wrap strings, it provides a translated access to string arguments
through the argument objects `str_data()` function. This takes a
an argument index (similarly to `data()`) and returns a reference to
the string variable.

</textarea>
</section>
<section data-markdown>
<textarea data-template>
```
/** i-time string plugin opcode example
    with only 1 input \n
    tprint Sin
 */
struct Tprint : csnd::Plugin<0,1> {
  int init() {
    csound->message(inargs.str_data(0).data);
    return OK;
  }
};
```
</textarea>
</section>
</section>

<section>
<section data-markdown>
<textarea data-template>
Fsigs
------------------------------------------------

For streaming spectral processing opcodes, we have a
different base class with extra facilities needed for their operation (`FPlugin`).
In Csound, fsig variables are held in a `PVSDAT` data structure. To
facilitate their manipulation, `CPOF` provides a wrapper class
`Fsig` for it. This holds a `pv_frame`, which itself contains a
series of `pv_bins` holding the floating-point data.
</textarea>
</section>

<section data-markdown>
<textarea data-template>

The `Fsig` class has the following methods:

* `init()`: initialisation from individual parameters or from an
existing fsig. Also allocates frame memory as needed.
* `dft_size()`, `hop_size()`, `win_size()`, `win_type()` and `nbins()`, returning the
PV data parameters.
* `count()`: get and set fsig framecount.
* `isSliding()`: checks for sliding mode.
* `fsig_format()`: returns the fsig data format.

</textarea>
</section>

<section data-markdown>
<textarea data-template>

The `pv_frame` class contains the following methods:

* `operator[]`: array-subscript access to the spectral frame
* `data()`: returns a pointer to the spectral frame data.
* `len()`: returns the length of the frame.
* `begin()` and `end()`: return iterators to the beginning and end of
the data frame.
* `iterator` and `const_iterator`: iterator types for this class.

</textarea>
</section>

<section data-markdown>
<textarea data-template>

Each Phase vocoder bin is held in a `pv_bin` container:

* `amp()`: returns the bin amplitude.
* `freq()`: returns the bin frequency.
* `amp(float a)`: sets the bin amplitude to a.
* `freq(float f)`: sets the bin frequency to f.
* `operator*(pv_bin f)`: multiply the amp of a pvs bin by f.amp.
* `operator*(MYFLT f)`: multiply the bin amp by f
* `operator*=()`: unary versions of the above.

</textarea>
</section>

<section data-markdown>
<textarea data-template>

```c++
/** f-sig plugin opcode example: pv gain change
    with 1 output and 2 inputs (f,k) \n
    fsig pvg fsin, kgain
 */
struct PVGain : csnd::FPlugin<1, 2> {
 static constexpr char const *otypes = "f";
 static constexpr char const *itypes = "fk";

 int init() {
  if (inargs.fsig_data(0).isSliding())
   return csound->init_error("sliding not supported");
    
  if (inargs.fsig_data(0).fsig_format()
   != csnd::fsig_format::pvs &&
    inargs.fsig_data(0).fsig_format()
   != csnd::fsig_format::polar)
    return csound->init_error("fsig format not supported");
		
  csnd::Fsig &fout = outargs.fsig_data(0);
  fout.init(csound, inargs.fsig_data(0));
  framecount = 0;
  return OK;
 }

 int kperf() {
  csnd::pv_frame &fin = inargs.fsig_data(0);
  csnd::pv_frame &fout = outargs.fsig_data(0);
  uint32_t i;

  if (framecount < fin.count()) {
   MYFLT g = inargs[1];
   std::transform(fin.begin(), fin.end(), fout.begin(),
    [g](csnd::pv_bin f){ return f *= g; });
   framecount = fout.count(fin.count());
  }
  return OK;
 }
};
```
</textarea>
</section>
</section>

<section>
<section data-markdown>
<textarea data-template>
Arrays
----------------------------------------------

Opcodes with array inputs or outputs use the data structure `ARRAYDAT`
for parameters. Again, in order to facilitate access to these argument
types, CPOF provides a wrapper class, Vector. This currently supports
only one-dimensional arrays (for multidimensional arrays a raw pointer
to `ARRAYDAT` should be used), which nevertheless covers the most common uses.
</textarea>
</section>
<section data-markdown>
<textarea data-template>
* `init()`: initialises an output variable.
* `operator[]`: array-subscript access to the vector data.
* `data()`: returns a pointer to the vector data.
* `len()`: returns the length of the vector.
* `begin()` and `end()`: return iterators to the beginning and end of
the vector.
* `iterator` and `const_iterator`: iterator types for this class.
* `data_array()`: returns a pointer to the vector data.
</textarea>
</section>

<section data-markdown>
<textarea data-template>
```c++
/** k-rate numeric array example
    with 1 output and 1 input \n
    kout[] simple kin[]
 */
struct SimpleArray : csnd::Plugin<1, 1> {
  int init() {
    csnd::Vector<MYFLT> &out = outargs.vector_data<MYFLT>(0);
    csnd::Vector<MYFLT> &in = inargs.vector_data<MYFLT>(0);
    out.init(csound, in.len());
    return OK;
  }

  int kperf() {
    csnd::Vector<MYFLT> &out = outargs.vector_data<MYFLT>(0);
    csnd::Vector<MYFLT> &in = inargs.vector_data<MYFLT>(0);
    std::copy(in.begin(), in.end(), out.begin());
    return OK;
  }
  };
```
</textarea>
</section>
</section>
<section data-markdown>
<textarea data-template>
Example
-------------------------------------------
```
/** i-time, k-rate array operator
    i/kout[] op i/kin[]
 */
template <MYFLT (*op)(MYFLT)>
struct ArrayOp : csnd::Plugin<1, 1> {

  int process(csnd::myfltvec &out, csnd::myfltvec &in) {
    std::transform(in.begin(), in.end(), out.begin(),
                   [](MYFLT f) { return op(f); });
    return OK;
  }

  int init() {
    csnd::myfltvec &out = outargs.myfltvec_data(0);
    csnd::myfltvec &in = inargs.myfltvec_data(0);
    out.init(csound, in.len());
    return process(out, in);
  }

  int kperf() {
   return process(outargs.myfltvec_data(0),
               inargs.myfltvec_data(0));
  }
};

#include <modload.h>
void csnd::on_load(Csound *csound) {
 csnd::plugin<ArrayOp<std::ceil>>(csound, "ceil", "i[]", "i[]",
                                   csnd::thread::i);
 csnd::plugin<ArrayOp<std::ceil>>(csound, "ceil", "k[]", "k[]",
                                   csnd::thread::ik);
 csnd::plugin<ArrayOp<std::floor>>(csound, "floor", "i[]", "i[]",
                                    csnd::thread::i);
 csnd::plugin<ArrayOp<std::floor>>(csound, "floor", "k[]", "k[]",
                                    csnd::thread::ik);
 csnd::plugin<ArrayOp<std::round>>(csound, "round", "i[]", "i[]",
                                    csnd::thread::i);
 csnd::plugin<ArrayOp<std::round>>(csound, "round", "k[]", "k[]",
                                    csnd::thread::ik);
 csnd::plugin<ArrayOp<std::trunc>>(csound, "int", "i[]", "i[]",
                                    csnd::thread::i);
 csnd::plugin<ArrayOp<std::trunc>>(csound, "int", "k[]", "k[]",
                                    csnd::thread::i);
 csnd::plugin<ArrayOp<std::exp2>>(csound, "powoftwo", "i[]", "i[]",
                                   csnd::thread::i);
 csnd::plugin<ArrayOp<std::exp2>>(csound, "powoftwo", "k[]", "k[]",
                                   csnd::thread::ik);
 csnd::plugin<ArrayOp<std::fabs>>(csound, "abs", "i[]", "i[]",
                                   csnd::thread::i);
 csnd::plugin<ArrayOp<std::fabs>>(csound, "abs", "k[]", "k[]",
                                   csnd::thread::ik);
 csnd::plugin<ArrayOp<std::log10>>(csound, "log2", "i[]", "i[]",
                                    csnd::thread::i);
 csnd::plugin<ArrayOp<std::log10>>(csound, "log2", "k[]", "k[]",
                                    csnd::thread::ik);
 csnd::plugin<ArrayOp<std::log10>>(csound, "log10", "i[]", "i[]",
                                    csnd::thread::i);
 csnd::plugin<ArrayOp<std::log10>>(csound, "log10", "k[]", "k[]",
                                    csnd::thread::ik);
 csnd::plugin<ArrayOp<std::log>>(csound, "log", "i[]", "i[]",
                                    csnd::thread::i);
 csnd::plugin<ArrayOp<std::log>>(csound, "log", "k[]", "k[]",
                                    csnd::thread::ik);
 csnd::plugin<ArrayOp<std::exp>>(csound, "exp", "i[]", "i[]",
                                      csnd::thread::i);
 csnd::plugin<ArrayOp<std::exp>>(csound, "exp", "k[]", "k[]",
                                     csnd::thread::ik);
 csnd::plugin<ArrayOp<std::sqrt>>(csound, "sqrt", "i[]", "i[]",
                                   csnd::thread::i);
 csnd::plugin<ArrayOp<std::sqrt>>(csound, "sqrt", "k[]", "k[]",
                                   csnd::thread::ik);
 csnd::plugin<ArrayOp<std::cos>>(csound, "cos", "i[]", "i[]",
                                    csnd::thread::i);
 csnd::plugin<ArrayOp<std::cos>>(csound, "cos", "k[]", "k[]",
                                  csnd::thread::ik);
 csnd::plugin<ArrayOp<std::sin>>(csound, "sin", "i[]", "i[]",
                                  csnd::thread::i);
 csnd::plugin<ArrayOp<std::sin>>(csound, "sin", "k[]", "k[]",
                                  csnd::thread::ik);
 csnd::plugin<ArrayOp<std::tan>>(csound, "tan", "i[]", "i[]",
                                    csnd::thread::i);
 csnd::plugin<ArrayOp<std::tan>>(csound, "tan", "k[]", "k[]",
                                  csnd::thread::ik);
 csnd::plugin<ArrayOp<std::acos>>(csound, "cosinv", "i[]", "i[]",
                                   csnd::thread::i);
 csnd::plugin<ArrayOp<std::acos>>(csound, "cosinv", "k[]", "k[]",
                                   csnd::thread::ik);
 csnd::plugin<ArrayOp<std::asin>>(csound, "sininv", "i[]", "i[]",
                                   csnd::thread::i);
 csnd::plugin<ArrayOp<std::asin>>(csound, "sininv", "k[]", "k[]",
                                   csnd::thread::ik);
 csnd::plugin<ArrayOp<std::atan>>(csound, "taninv", "i[]", "i[]",
                                   csnd::thread::i);
 csnd::plugin<ArrayOp<std::atan>>(csound, "taninv", "k[]", "k[]",
                                   csnd::thread::ik);
 csnd::plugin<ArrayOp<std::cosh>>(csound, "cosh", "i[]", "i[]",
                                   csnd::thread::i);
 csnd::plugin<ArrayOp<std::cosh>>(csound, "cosh", "k[]", "k[]",
                                   csnd::thread::ik);
 csnd::plugin<ArrayOp<std::sinh>>(csound, "sinh", "i[]", "i[]",
                                   csnd::thread::i);
 csnd::plugin<ArrayOp<std::sinh>>(csound, "sinh", "k[]", "k[]",
                                   csnd::thread::ik);
 csnd::plugin<ArrayOp<std::tanh>>(csound, "tanh", "i[]", "i[]",
                                   csnd::thread::i);
 csnd::plugin<ArrayOp<std::tanh>>(csound, "tanh", "k[]", "k[]",
                                   csnd::thread::ik);
 csnd::plugin<ArrayOp<std::cbrt>>(csound, "cbrt", "i[]", "i[]",
                                   csnd::thread::i);
}
```
</textarea>
</section>
<section data-markdown>
<textarea data-template>
Building the opcodes
-------------------------------------------

In order to plugin opcodes with CPOF, we require a c++
compiler using c++11 mode (`-std=c++11`), and the Csound public
headers (including `plugin.h`). The code should be built as a dynamic/shared
library (e.g so in Linux and dylib in OSX). CPOF does not impose any
link-time dependencies (not even to Csound).

<div class=align-center>
[http://csound.github.io](http://csound.github.io)
</div>
</textarea>
</section>

</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
		Reveal.initialize({
		   
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				],       
			});
		</script>
	</body>
</html>
